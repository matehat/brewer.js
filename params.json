{"name":"Brewer.js","tagline":"Your asset management best friend","body":"## Brewer.js\r\n#### Your asset management best friend.\r\n\r\nBrewer.js is a tool that eases all sorts of tasks related to the management of \r\nstylesheets and javascript source files. From a single command, it takes care of :\r\n\r\n* Compilation of coffee-script source files to javascript\r\n* Compilation of LESS or Stylus files to CSS\r\n* Bundling different files (javascript or CSS) into a single file (optionally compressing it) while maintaining references and their proper ordering.\r\n* Watching a directory for changes, triggering any or all of the above.\r\n\r\nWatching a whole project structure of Coffee-script, LESS or Stylus source files can be as easy as :\r\n\r\n    $ brake watch\r\n    Info Watching project /path/to/current/working/directory\r\n    Compiled coffee/test.coffee\r\n    Compiled less/index.less\r\n    Packaged build/css/index.css\r\n    Compressed build/css/index.css\r\n\r\n### Contributing\r\n\r\nIf you wish to improve Brewer.js, feel free to fork the project on Github. Then, clone your fork somewhere on your computer, where you would do your own changes. If you are going to do this, you might want to `cd` to your working copy and :\r\n\r\n    $ npm link\r\n    \r\nThis will turn your working copy as a global node module so you can use your version of the executable `brake` to test things out. You can always reinstall the official version using :\r\n\r\n    $ npm install -g brewer\r\n    \r\nAlways update the tests (located in `tests/`) to reflect your changes and make sure they pass before submitting your changes. You will need [coffee-script](https://github.com/jashkenas/coffee-script) to be installed globally to run the tests. You can run the tests as follow :\r\n\r\n    $ cake test\r\n    \r\nWhen you feel your fork is awesome (that includes you've updated the tests to reflect your changes and all the tests pass), go ahead and do a **Pull Request**, explaining what awesomeness you've added. If everything is in order and the project stays consistent with its goal, we'll merge it right in!\r\n\r\n### Installation\r\n\r\n#### Using a prepared package\r\n\r\nTo setup Brewer.js, make sure you have [installed Node.js](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager). When this is done, enter the terminal and type.\r\n\r\n    $ npm install -g brewer\r\n\r\nThe `-g` flag is used to make the installation global, so you get access to the `brake` executable. Then, from a project directory you wish to manage using Brewer.js\r\n\r\n    $ brake init [<template name>]\r\n\r\nThe `<template name>` part is optional. Anyway, for the moment, there is only one template available, **lesscoffee**, which is also the default. This template sets up LESS and Coffeescript support for the current directory.\r\n\r\nWhat this does is create a Brewfile in the current directory, according to the template provided and run `brake make` on it (see Usage).\r\n\r\n#### Using this repository\r\n\r\nYou need Node.js, as well as coffee-script, installed globally to get the `cake` executable. You can do so by doing :\r\n\r\n    $ npm install -g coffee-script\r\n    \r\nThen, to get brewer.js to work locally\r\n\r\n    $ git clone git@github.com:matehat/brewer.js.git brewer\r\n    $ cd brewer\r\n    $ npm install\r\n    $ cake build\r\n  \r\nThen, if you want the `brewer` executable, you can do\r\n\r\n    $ npm link\r\n\r\n### Brewfile\r\n\r\nA <strong>Brewfile</strong> is a file that sits at the root folder of your project, named, \r\nwell, \"Brewfile\", which syntax is plain [Coffeescript](http://coffeescript.org). It is used to specify the structure of the project to Brewer.js, so it knows what to do when you tell it to `make`, `watch` or `clean`. \r\n\r\n##### Packages\r\n\r\nAt the top-level of the Brewfile, the following functions are available :\r\n\r\n```coffeescript\r\n# In Brewfile\r\n\r\n@stylesheets 'package_name', ->\r\n  # package body ...\r\n\r\n@javascript 'other_package_name', ->\r\n  # package body ...\r\n```\r\n\r\nThose two functions can be used interchangeably with `js` or `css` to be more concise. The `package_name` is used to identify certain parts of a project, in case you would like to run `$ brake make package_name`. A **Package** is a conceptual component of a project in which you can define **bundles** and in which files can *import* each other. A file contained in a package can really be anywhere on the file system -- a package is not bound to a specific directory.\r\n\r\nPackage can receive options, which can be specified in one of two ways :\r\n\r\n````coffeescript\r\n# In Brewfile\r\n\r\n@javascript 'package_name', {build: './build', compress: true}, ->\r\n  # package body\r\n\r\n# equivalent to\r\n@javascript 'package_name', ->\r\n  @options {build: './build', compress: true}\r\n```\r\n\r\nThe `build` option specifies where to put bundles aggregated from source files, and `compress` &hellip; well, I think you can guess that one. \r\n\r\n`@options` is a method available in the package definition body, that specifies additional options for the package. Another such method is `@bundles(bundle1, bundle2, ...)` which specifies file names for bundles in the package (see **Bundles** below). These two methods are prefixed with a `@`, meaning that they are members of the package body context. Other methods of this kind are available, such as those to define **sources** in a package. \r\n\r\n##### Sources\r\n\r\nSources represent a folder on the file system, where files can be found. One or many can exist within a package, providing it with files to compile, bundle and compress. A source can be of one of many available types : *coffeescript*, *javascript*, *css*, *less* or *stylus*. One restriction about this source type is that a package can only contain sources that are either of its own type, or that can be compiled into its own type (remember a package also have a type).\r\n\r\nNow for a real-world example, so we don't get lost too quickly. Say we want to make a cool looking website using jQuery, Bootstrap and Chosen. Each of these libraries have their own source files, of different types and we want to manage all of that neatly. Here is the directory structure :\r\n\r\n```\r\nRoot folder\r\n|-- js\r\n|-- coffee\r\n|-- css\r\n|-- less\r\n|-- vendor\r\n    |-- bootstrap\r\n    |   |- less\r\n    |   |- js\r\n    |\r\n    |-- chosen\r\n    |-- jquery.js\r\n```\r\n\r\nSo there are files that ends up as javascript and those that ends up as css. Let's write a Brewfile that takes this structure into account.\r\n\r\n```coffeescript\r\n@javascript 'scripts', {build: './js'} ->\r\n    @bundles 'home', 'products'\r\n    \r\n    @coffeescript './coffee'\r\n    @js './vendor'\r\n\r\n@stylesheets 'styles', {build: './css'} ->\r\n    @bundles 'home', 'products'\r\n\r\n    @less './less'\r\n    @less './vendor/bootstrap/less'\r\n    @css './vendor'\r\n```\r\n\r\nSo what we're looking at now is a package for javascripts that looks for coffeescript files in `./coffee`, as well as for javascript files in `./vendor`, `./vendor/chosen` and `./vendor/bootstrap/js`. Now let's look at what a bundle would look like :\r\n\r\n```coffeescript\r\n# in coffee/home.coffee\r\n# import [\"jquery\", \"chosen/chosen.jquery.js\"]\r\n\r\n$ -> $('select').chosen()\r\n```\r\n\r\nIf we had been running `brake watch` while we wrote that script and saved it, we would have seen a file appear, named `./js/home.js`, containing an aggregate file of jquery, chosen and our little script compiled into javascript. Since we didn't provide the `output` option, a compiled javascript version of just `coffee/home.coffee` can be found in `./_cache`. If we wanted it to appear somewhere more meaningful, we could set the `output` option on a source directive. A more complete example of the above could be :\r\n\r\n```coffeescript\r\n@javascript 'scripts', {build: './build/js'} ->\r\n    @bundles 'home', 'products'\r\n    \r\n    @coffeescript './coffee', {output: './js'}\r\n    @js './vendor'\r\n\r\n@stylesheets 'styles', {build: './build/css'} ->\r\n    @bundles 'home', 'products'\r\n\r\n    @less './less', {output: './css'}\r\n    @css './vendor'\r\n```\r\n\r\nThis dedicates a directory `./build`, to contain files that would be deployed, and all source files in separate directories. You may have noticed we used `@css` and `@js` names to mean stylesheets and javascript respectively. As we said earlier, those are drop-in replacements.\r\n\r\n### Usage\r\n\r\nThe command-line interface for brewer provides a few methods to manage the asset project. \r\n\r\n* `brake init <template_name>`\r\n\r\n    This command tells brewer to make a Brewfile in the current directory, according to the template provided, and make an initial directory structure to support the project.\r\n\r\n* `brake [all|<package>*]`\r\n\r\n    This command tells brewer to look for files to compile (coffeescript, less, etc.) into their javascript or css counterparts, product bundles and compress them if necessary. This intelligently selects only the tasks that needs to be done, skipping files that haven't change.\r\n    \r\n* `brake clean [<package>*]`\r\n\r\n    This command tells brewer to delete files that strongly depends on source files, such as those that are completely derived from the compilation of another file, bundles and their compressed counterparts.\r\n    \r\n* `brake watch`\r\n\r\n    This command tells brewer to first run `brake make` on the current directory and watch for changes (file content change, new files, moved files or deleted files).\r\n    \r\n* `brake install`\r\n\r\n    This command tells Brewer.js to install all missing Node.js modules that it needs to work properly\r\n    with the current project. For instance, had I put a few `@coffeescript` source directives in the project's \r\n    Brewfile, Brewer.js will make sure the coffee-script module is available, installing it under its own \r\n    project directory if not.\r\n\r\n### MIT License\r\n\r\nCopyright &copy; 2012 Mathieu D'Amours\r\n\r\nPermission is hereby granted, free of charge, to any person \r\nobtaining a copy of this software and associated documentation \r\nfiles (the \"Software\"), to deal in the Software without \r\nrestriction, including without limitation the rights to use, \r\ncopy, modify, merge, publish, distribute, sublicense, \r\nand/or sell copies of the Software, and to permit persons to \r\nwhom the Software is furnished to do so, subject to the \r\nfollowing conditions:\r\n\r\nThe above copyright notice and this permission notice shall be \r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \r\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR \r\nOTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}